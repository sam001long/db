<!-- 1) 先載 three.js（用 jsDelivr，比 unpkg 在某些網路環境更穩） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<!-- 2) 再載 GLTFLoader（一定要在 three 之後） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/loaders/GLTFLoader.js"></script>

<!-- 3) 最後才是你的主程式；這段會等 THREE 存在再跑，避免時序問題 -->
<script>
(function waitForThree(){
  if (!window.THREE) { setTimeout(waitForThree, 50); return; }

  // ===== 下面開始放你原本的主程式（我已略過和 THREE 無關的樣式/HTML） =====
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1020);

  const camera = new THREE.PerspectiveCamera(50, 16/9, 0.1, 100);
  camera.position.set(0, 1.4, 2);

  const light = new THREE.HemisphereLight(0xffffff, 0x222233, 1.2);
  scene.add(light);

  let model, mixer, clock = new THREE.Clock();

  function resize(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    if (canvas.width !== w || canvas.height !== h) {
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
  }

  // --- Bone Inspector helpers ---
  const bonePanel = document.getElementById('bonePanel');
  const boneList  = document.getElementById('boneList');
  const boneFilter= document.getElementById('boneFilter');
  function bonePath(node){
    const names=[]; let p=node;
    while(p){ names.push(p.name||p.type); p=p.parent; }
    return names.reverse().join(' / ');
  }
  function renderBones(root){
    const all=[];
    root.traverse(o=>{
      if(o.isBone){ all.push({name:o.name, path:bonePath(o)}); }
    });
    bonePanel.hidden=false;
    const draw=(q='')=>{
      const k=q.trim().toLowerCase();
      const rows=(k?all.filter(x=>x.name.toLowerCase().includes(k)||x.path.toLowerCase().includes(k)):all)
        .map(x=>`<div><b>${x.name}</b><br><span style="color:#8fa3c7">${x.path}</span></div>`).join('<hr style="border:0;border-top:1px solid #1f2a4a;margin:6px 0">');
      boneList.innerHTML = rows || '<i style="color:#8fa3c7">no match</i>';
    };
    draw(); boneFilter.oninput = e=>draw(e.target.value);
    console.group('Bones'); all.forEach(x=>console.log(x.name,'|',x.path)); console.groupEnd();
  }

  // 載入模型（如改檔名/路徑，這裡也要改）
  const gltfLoader = new THREE.GLTFLoader();
  gltfLoader.load('./assets/model.glb', (gltf)=>{
    model = gltf.scene;
    model.traverse(o=>{ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; } });
    scene.add(model);
    mixer = new THREE.AnimationMixer(model);
    renderBones(model);
  }, undefined, (err)=>console.error('Load model error:', err));

  async function loadMotionList(){
    const res = await fetch('./motions/index.json', {cache:'no-store'});
    const data = await res.json();
    const sel = document.getElementById('motion');
    sel.innerHTML = (data.items||[]).map(x=>`<option value="${x.file}">${x.label}</option>`).join('');
    return data.items||[];
  }
  async function playMotion(file){
    if(!mixer || !file) return;
    const clipData = await fetch('./motions/'+file, {cache:'no-store'}).then(r=>r.json());
    const clip = THREE.AnimationClip.parse(clipData);
    mixer.stopAllAction();
    const action = mixer.clipAction(clip);
    action.reset().setLoop(THREE.LoopRepeat, Infinity).play();
  }
  document.getElementById('motion').addEventListener('change', (e)=>playMotion(e.target.value));
  document.getElementById('reload').addEventListener('click', async ()=>{
    const items = await loadMotionList();
    if(items[0]) playMotion(items[0].file);
  });

  function animate(){
    requestAnimationFrame(animate);
    resize();
    const dt = clock.getDelta();
    if (mixer) mixer.update(dt);
    renderer.render(scene, camera);
  }
  animate();
  loadMotionList().then(items => { if(items[0]) playMotion(items[0].file); });
})();
</script>
